#!/usr/bin/guile
!#

; anagrams - Find all anagrams of a word
; Copyright (C) 2011  Andrea Bolognani <andrea.bolognani@roundhousecode.com>
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along
; with this program; if not, write to the Free Software Foundation, Inc.,
; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

(use-modules (ice-9 rdelim))

; Dictionary file to use
(define dict-file "/usr/share/dict/words")

(define (foldl pred initial-value lst)
  (define (doit v l)
            (if (null? l)
                v
                (doit (pred (car l) v) (cdr l))))
  (doit initial-value lst))

(define (range from to)
  (define (doit i acc)
    (if (< i from)
        acc
        (doit (- i 1) (cons i acc))))
  (doit to (list)))

(define (list-merge l1 l2)
  (define (doit a b)
    (if (null? a)
        b
        (doit (cdr a)
              (cons (car a) b))))
  (doit (reverse l1) l2))

(define (list-flatten lst)
  (foldl (lambda (e a)
           (list-merge e a))
         (list)
         lst))

(define (list-remove lst i)
  (define (doit l c acc)
    (if (zero? c)
        (append (reverse acc)
                (cdr l))
        (doit (cdr l)
              (- c 1)
              (cons (car l) acc))))
  (doit lst i (list)))

(define (list-remove-duplicates lst)
  (define (doit l a)
    (if (null? l)
        (reverse a)
        (if (not (member (car l) (cdr l)))
            (doit (cdr l) (cons (car l) a))
            (doit (cdr l) a))))
  (doit lst (list)))

(define (cons/all h lst)
  (map (lambda (e)
         (cons h e))
       lst))

; Find all permutations of a list.
;
; Not the smartest algorithm. Not even properly tail-recursive. Oh well.
(define (perm lst)
  (define (doit l acc)
    (if (null? l)
        acc
        (list-flatten (foldl (lambda (i a)
                               (cons (doit (list-remove l i)
                                           (cons/all (list-ref l i) acc))
                                     a))
                             (list)
                             (range 0 (- (length l) 1))))))
  (doit lst (list (list))))

; Used to crudely filter out dictionary words that can't possibly be
; acronyms, that is, the ones starting with a letter that doesn't appear
; in the word.
;
; Filtering these out at dictionary load time improves performance tenfold.
(define (maybe-anagram? word pattern)
  (member (car word) pattern))

; Load the dictionary in a not-completely-dumb way.
;
; Dictionary entries are converted to lower case, and entries that
; can't possibly be acronyms are ignored altogether.
(define (load-dict file pattern)
  (define (doit lines)
    (let ((line (read-line)))
      (if (eof-object? line)
          lines
          (let ((line (string-downcase line)))
            (if (and (not (equal? line ""))
                     (maybe-anagram? (string->list line) pattern))
                (doit (cons line lines))
                (doit lines))))))
  (with-input-from-file file
    (lambda ()
      (doit (list)))))

; Program entry point
(define (anagrams args)
  (if (< (length args) 2)
      (begin
        (display "Usage: ")
        (display (car args))
        (display " WORD")
        (newline)
        1)
      (let* ((needle   (string-downcase (cadr args)))
             (needle   (string->list needle))
             (haystack (load-dict dict-file needle))
             (needles  (perm needle))
             (needles  (list-remove-duplicates needles))
             (needles  (map list->string needles)))
        (display "Checking ")
        (display (length needles))
        (display " candidate anagrams against ")
        (display (length haystack))
        (display " dictionary entries...")
        (newline)
        (foldl (lambda (needle retval)
                 (if (member needle haystack)
                     (begin
                       (display needle)
                       (newline)
                       0)
                     retval))
               1
               needles))))

(exit (anagrams (program-arguments)))

; vim: set filetype=scheme :
